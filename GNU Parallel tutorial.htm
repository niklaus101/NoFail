<!DOCTYPE HTML>
<!-- saved from url=(0079)https://www.gnu.org/software/parallel/parallel_tutorial.html -->
<!--?xml version="1.0" ?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><HTML 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><META content="IE=11.0000" 
http-equiv="X-UA-Compatible">
 <TITLE>GNU Parallel tutorial</TITLE> 
<META http-equiv="content-type" content="text/html; charset=utf-8"> <LINK href="mailto:root@localhost" 
rev="made"> 
<META name="GENERATOR" content="MSHTML 11.00.9600.18125"></HEAD> 
<BODY>
<UL id="index">
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#GNU-Parallel-Tutorial">GNU 
  Parallel Tutorial</A></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Prerequisites">Prerequisites</A></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Input-sources">Input 
  sources</A>     
  <UL>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#A-single-input-source">A 
    single input source</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Multiple-input-sources">Multiple 
    input sources</A>         
    <UL>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Linking-arguments-from-input-sources">Linking 
      arguments from input sources</A></LI></UL></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Changing-the-argument-separator">Changing 
    the argument separator.</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Changing-the-argument-delimiter">Changing 
    the argument delimiter</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#End-of-file-value-for-input-source">End-of-file 
    value for input source</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Skipping-empty-lines">Skipping 
    empty lines</A></LI></UL></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Building-the-command-line">Building 
  the command line</A>     
  <UL>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#No-command-means-arguments-are-commands">No 
    command means arguments are commands</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Replacement-strings">Replacement 
    strings</A>         
    <UL>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#The-7-predefined-replacement-strings">The 
      7 predefined replacement strings</A></LI>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Changing-the-replacement-strings">Changing 
      the replacement strings</A></LI>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Perl-expression-replacement-string">Perl 
      expression replacement string</A></LI>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Positional-replacement-strings">Positional 
      replacement strings</A></LI>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Positional-perl-expression-replacement-string">Positional 
      perl expression replacement string</A></LI>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Input-from-columns">Input 
      from columns</A></LI>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Header-defined-replacement-strings">Header 
      defined replacement strings</A></LI>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#More-pre-defined-replacement-strings">More 
      pre-defined replacement strings</A></LI></UL></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#More-than-one-argument">More 
    than one argument</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Quoting">Quoting</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Trimming-space">Trimming 
    space</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Respecting-the-shell">Respecting 
    the shell</A></LI></UL></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Controlling-the-output">Controlling 
  the output</A>     
  <UL>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Saving-output-into-files">Saving 
    output into files</A></LI></UL></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Controlling-the-execution">Controlling 
  the execution</A>     
  <UL>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Number-of-simultaneous-jobs">Number 
    of simultaneous jobs</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Shuffle-job-order">Shuffle 
    job order</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Interactivity">Interactivity</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#A-terminal-for-every-job">A 
    terminal for every job</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Timing">Timing</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Progress-information">Progress 
    information</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Termination">Termination</A> 
            
    <UL>
      <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Termination-signals-advanced">Termination 
      signals (advanced)</A></LI></UL></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Limiting-the-resources">Limiting 
    the resources</A></LI></UL></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Remote-execution">Remote 
  execution</A>     
  <UL>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Sshlogin">Sshlogin</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Transferring-files">Transferring 
    files</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Working-dir">Working 
    dir</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Avoid-overloading-sshd">Avoid 
    overloading sshd</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Ignore-hosts-that-are-down">Ignore 
    hosts that are down</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Running-the-same-commands-on-all-hosts">Running 
    the same commands on all hosts</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Transferring-environment-variables-and-functions">Transferring 
    environment variables and functions</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Showing-what-is-actually-run">Showing 
    what is actually run</A></LI></UL></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Saving-to-an-SQL-base-advanced">Saving 
  to an SQL base (advanced)</A>     
  <UL>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#CSV-as-SQL-base">CSV 
    as SQL base</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#DBURL-as-table">DBURL 
    as table</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Using-multiple-workers">Using 
    multiple workers</A></LI></UL></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#pipe">--pipe</A> 
      
  <UL>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Chunk-size">Chunk 
    size</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Records">Records</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Record-separators">Record 
    separators</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Header">Header</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#pipepart">--pipepart</A></LI></UL></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Shebang">Shebang</A> 
      
  <UL>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Input-data-and-parallel-command-in-the-same-file">Input 
    data and parallel command in the same file</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Parallelizing-existing-scripts">Parallelizing 
    existing scripts</A></LI></UL></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Semaphore">Semaphore</A> 
      
  <UL>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Mutex">Mutex</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Counting-semaphore">Counting 
    semaphore</A></LI>
    <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Timeout">Timeout</A></LI></UL></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Informational">Informational</A></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Profiles">Profiles</A></LI>
  <LI><A href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Spread-the-word">Spread 
  the word</A></LI></UL>
<H1 id="GNU-Parallel-Tutorial">GNU Parallel Tutorial</H1>
<P>This tutorial shows off much of GNU <B>parallel</B>'s functionality. The 
tutorial is meant to learn the options in GNU <B>parallel</B>. The tutorial is 
not to show realistic examples from the real world.</P>
<P>Spend an hour walking through the tutorial. Your command line will love you 
for it.</P>
<H1 id="Prerequisites">Prerequisites</H1>
<P>To run this tutorial you must have the following:</P>
<DL>
  <DT id="parallel-version-20160822">parallel &gt;= version 20160822</DT>
  <DD>
  <P>Install the newest version using your package manager (recommended for 
  security reasons) or with this command:</P>
<PRE><CODE>  (wget -O - pi.dk/3 || curl pi.dk/3/ || fetch -o - http://pi.dk/3) | bash</CODE></PRE>
  <P>This will also install the newest version of the tutorial which you can see 
  by running this:</P>
<PRE><CODE>  man parallel_tutorial</CODE></PRE>
  <P>Most of the tutorial will work on older versions, too.</P></DD>
  <DT id="abc-file">abc-file:</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  parallel -k echo ::: A B C &gt; abc-file</CODE></PRE></DD>
  <DT id="def-file">def-file:</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  parallel -k echo ::: D E F &gt; def-file</CODE></PRE></DD>
  <DT id="abc0-file">abc0-file:</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  perl -e 'printf "A\0B\0C\0"' &gt; abc0-file</CODE></PRE></DD>
  <DT id="abc_-file">abc_-file:</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  perl -e 'printf "A_B_C_"' &gt; abc_-file</CODE></PRE></DD>
  <DT id="tsv-file.tsv">tsv-file.tsv</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  perl -e 'printf "f1\tf2\nA\tB\nC\tD\n"' &gt; tsv-file.tsv</CODE></PRE></DD>
  <DT id="num8">num8</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  perl -e 'for(1..8){print "$_\n"}' &gt; num8</CODE></PRE></DD>
  <DT id="num128">num128</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  perl -e 'for(1..128){print "$_\n"}' &gt; num128</CODE></PRE></DD>
  <DT id="num30000">num30000</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  perl -e 'for(1..30000){print "$_\n"}' &gt; num30000</CODE></PRE></DD>
  <DT id="num1000000">num1000000</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  perl -e 'for(1..1000000){print "$_\n"}' &gt; num1000000</CODE></PRE></DD>
  <DT id="num_-header">num_%header</DT>
  <DD>
  <P>The file can be generated by this command:</P>
<PRE><CODE>  (echo %head1; echo %head2; perl -e 'for(1..10){print "$_\n"}') &gt; num_%header</CODE></PRE></DD>
  <DT id="For-remote-running:-ssh-login-on-2-servers-with-no-password-in-SERVER1-and-SERVER2-must-work">For 
  remote running: ssh login on 2 servers with no password in $SERVER1 and 
  $SERVER2 must work.</DT>
  <DD>
<PRE><CODE>  SERVER1=server.example.com
  SERVER2=server2.example.net</CODE></PRE>
  <P>So you must be able to do this:</P>
<PRE><CODE>  ssh $SERVER1 echo works
  ssh $SERVER2 echo works</CODE></PRE>
  <P>It can be setup by running 'ssh-keygen -t dsa; ssh-copy-id $SERVER1' and 
  using an empty pass phrase.</P></DD></DL>
<H1 id="Input-sources">Input sources</H1>
<P>GNU <B>parallel</B> reads input from input sources. These can be files, the 
command line, and stdin (standard input or a pipe).</P>
<H2 id="A-single-input-source">A single input source</H2>
<P>Input can be read from the command line:</P>
<PRE><CODE>  parallel echo ::: A B C</CODE></PRE>
<P>Output (the order may be different because the jobs are run in parallel):</P>
<PRE><CODE>  A
  B
  C</CODE></PRE>
<P>The input source can be a file:</P>
<PRE><CODE>  parallel -a abc-file echo</CODE></PRE>
<P>Output: Same as above.</P>
<P>STDIN (standard input) can be the input source:</P>
<PRE><CODE>  cat abc-file | parallel echo</CODE></PRE>
<P>Output: Same as above.</P>
<H2 id="Multiple-input-sources">Multiple input sources</H2>
<P>GNU <B>parallel</B> can take multiple input sources given on the command 
line. GNU <B>parallel</B> then generates all combinations of the input 
sources:</P>
<PRE><CODE>  parallel echo ::: A B C ::: D E F</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A D
  A E
  A F
  B D
  B E
  B F
  C D
  C E
  C F</CODE></PRE>
<P>The input sources can be files:</P>
<PRE><CODE>  parallel -a abc-file -a def-file echo</CODE></PRE>
<P>Output: Same as above.</P>
<P>STDIN (standard input) can be one of the input sources using <B>-</B>:</P>
<PRE><CODE>  cat abc-file | parallel -a - -a def-file echo</CODE></PRE>
<P>Output: Same as above.</P>
<P>Instead of <B>-a</B> files can be given after <B>::::</B>:</P>
<PRE><CODE>  cat abc-file | parallel echo :::: - def-file</CODE></PRE>
<P>Output: Same as above.</P>
<P>::: and :::: can be mixed:</P>
<PRE><CODE>  parallel echo ::: A B C :::: def-file</CODE></PRE>
<P>Output: Same as above.</P>
<H3 id="Linking-arguments-from-input-sources">Linking arguments from input 
sources</H3>
<P>With <B>--link</B> you can link the input sources and get one argument from 
each input source:</P>
<PRE><CODE>  parallel --link echo ::: A B C ::: D E F</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A D
  B E
  C F</CODE></PRE>
<P>If one of the input sources is too short, its values will wrap:</P>
<PRE><CODE>  parallel --link echo ::: A B C D E ::: F G</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A F
  B G
  C F
  D G
  E F</CODE></PRE>
<P>For more flexible linking you can use <B>:::+</B> and <B>::::+</B>. They work 
like <B>:::</B> and <B>::::</B> except they link the previous input source to 
this input source.</P>
<P>This will link ABC to GHI:</P>
<PRE><CODE>  parallel echo :::: abc-file :::+ G H I :::: def-file</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A G D
  A G E
  A G F
  B H D
  B H E
  B H F
  C I D
  C I E
  C I F</CODE></PRE>
<P>This will link GHI to DEF:</P>
<PRE><CODE>  parallel echo :::: abc-file ::: G H I ::::+ def-file</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A G D
  A H E
  A I F
  B G D
  B H E
  B I F
  C G D
  C H E
  C I F</CODE></PRE>
<P>If one of the input sources is too short when using <B>:::+</B> or 
<B>::::+</B>, the rest will be ignored:</P>
<PRE><CODE>  parallel echo ::: A B C D E :::+ F G</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A F
  B G</CODE></PRE>
<H2 id="Changing-the-argument-separator">Changing the argument separator.</H2>
<P>GNU <B>parallel</B> can use other separators than <B>:::</B> or <B>::::</B>. 
This is typically useful if <B>:::</B> or <B>::::</B> is used in the command to 
run:</P>
<PRE><CODE>  parallel --arg-sep ,, echo ,, A B C :::: def-file</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A D
  A E
  A F
  B D
  B E
  B F
  C D
  C E
  C F</CODE></PRE>
<P>Changing the argument file separator:</P>
<PRE><CODE>  parallel --arg-file-sep // echo ::: A B C // def-file</CODE></PRE>
<P>Output: Same as above.</P>
<H2 id="Changing-the-argument-delimiter">Changing the argument delimiter</H2>
<P>GNU <B>parallel</B> will normally treat a full line as a single argument: It 
uses <B>\n</B> as argument delimiter. This can be changed with <B>-d</B>:</P>
<PRE><CODE>  parallel -d _ echo :::: abc_-file</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A
  B
  C</CODE></PRE>
<P>NUL can be given as <B>\0</B>:</P>
<PRE><CODE>  parallel -d '\0' echo :::: abc0-file</CODE></PRE>
<P>Output: Same as above.</P>
<P>A shorthand for <B>-d '\0'</B> is <B>-0</B> (this will often be used to read 
files from <B>find ... -print0</B>):</P>
<PRE><CODE>  parallel -0 echo :::: abc0-file</CODE></PRE>
<P>Output: Same as above.</P>
<H2 id="End-of-file-value-for-input-source">End-of-file value for input 
source</H2>
<P>GNU <B>parallel</B> can stop reading when it encounters a certain value:</P>
<PRE><CODE>  parallel -E stop echo ::: A B stop C D</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A
  B</CODE></PRE>
<H2 id="Skipping-empty-lines">Skipping empty lines</H2>
<P>Using <B>--no-run-if-empty</B> GNU <B>parallel</B> will skip empty lines.</P>
<PRE><CODE>  (echo 1; echo; echo 2) | parallel --no-run-if-empty echo</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  1
  2</CODE></PRE>
<H1 id="Building-the-command-line">Building the command line</H1>
<H2 id="No-command-means-arguments-are-commands">No command means arguments are 
commands</H2>
<P>If no command is given after parallel the arguments themselves are treated as 
commands:</P>
<PRE><CODE>  parallel ::: ls 'echo foo' pwd</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  [list of files in current dir]
  foo
  [/path/to/current/working/dir]</CODE></PRE>
<P>The command can be a script, a binary or a Bash function if the function is 
exported using <B>export -f</B>:</P>
<PRE><CODE>  # Only works in Bash
  my_func() {
    echo in my_func $1
  }
  export -f my_func
  parallel my_func ::: 1 2 3</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  in my_func 1
  in my_func 2
  in my_func 3</CODE></PRE>
<H2 id="Replacement-strings">Replacement strings</H2>
<H3 id="The-7-predefined-replacement-strings">The 7 predefined replacement 
strings</H3>
<P>GNU <B>parallel</B> has several replacement strings. If no replacement 
strings are used the default is to append <B>{}</B>:</P>
<PRE><CODE>  parallel echo ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A/B.C</CODE></PRE>
<P>The default replacement string is <B>{}</B>:</P>
<PRE><CODE>  parallel echo {} ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A/B.C</CODE></PRE>
<P>The replacement string <B>{.}</B> removes the extension:</P>
<PRE><CODE>  parallel echo {.} ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A/B</CODE></PRE>
<P>The replacement string <B>{/}</B> removes the path:</P>
<PRE><CODE>  parallel echo {/} ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  B.C</CODE></PRE>
<P>The replacement string <B>{//}</B> keeps only the path:</P>
<PRE><CODE>  parallel echo {//} ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A</CODE></PRE>
<P>The replacement string <B>{/.}</B> removes the path and the extension:</P>
<PRE><CODE>  parallel echo {/.} ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  B</CODE></PRE>
<P>The replacement string <B>{#}</B> gives the job number:</P>
<PRE><CODE>  parallel echo {#} ::: A B C</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  1
  2
  3</CODE></PRE>
<P>The replacement string <B>{%}</B> gives the job slot number (between 1 and 
number of jobs to run in parallel):</P>
<PRE><CODE>  parallel -j 2 echo {%} ::: A B C</CODE></PRE>
<P>Output (the order may be different and 1 and 2 may be swapped):</P>
<PRE><CODE>  1
  2
  1</CODE></PRE>
<H3 id="Changing-the-replacement-strings">Changing the replacement strings</H3>
<P>The replacement string <B>{}</B> can be changed with <B>-I</B>:</P>
<PRE><CODE>  parallel -I ,, echo ,, ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A/B.C</CODE></PRE>
<P>The replacement string <B>{.}</B> can be changed with 
<B>--extensionreplace</B>:</P>
<PRE><CODE>  parallel --extensionreplace ,, echo ,, ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A/B</CODE></PRE>
<P>The replacement string <B>{/}</B> can be replaced with 
<B>--basenamereplace</B>:</P>
<PRE><CODE>  parallel --basenamereplace ,, echo ,, ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  B.C</CODE></PRE>
<P>The replacement string <B>{//}</B> can be changed with 
<B>--dirnamereplace</B>:</P>
<PRE><CODE>  parallel --dirnamereplace ,, echo ,, ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A</CODE></PRE>
<P>The replacement string <B>{/.}</B> can be changed with 
<B>--basenameextensionreplace</B>:</P>
<PRE><CODE>  parallel --basenameextensionreplace ,, echo ,, ::: A/B.C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  B</CODE></PRE>
<P>The replacement string <B>{#}</B> can be changed with 
<B>--seqreplace</B>:</P>
<PRE><CODE>  parallel --seqreplace ,, echo ,, ::: A B C</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  1
  2
  3</CODE></PRE>
<P>The replacement string <B>{%}</B> can be changed with 
<B>--slotreplace</B>:</P>
<PRE><CODE>  parallel -j2 --slotreplace ,, echo ,, ::: A B C</CODE></PRE>
<P>Output (the order may be different and 1 and 2 may be swapped):</P>
<PRE><CODE>  1
  2
  1</CODE></PRE>
<H3 id="Perl-expression-replacement-string">Perl expression replacement 
string</H3>
<P>When predefined replacement strings are not flexible enough a perl expression 
can be used instead. One example is to remove two extensions: foo.tar.gz becomes 
foo</P>
<PRE><CODE>  parallel echo '{= s:\.[^.]+$::;s:\.[^.]+$::; =}' ::: foo.tar.gz</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  foo</CODE></PRE>
<P>In <B>{= =}</B> you can access all of GNU <B>parallel</B>'s internal 
functions and variables. A few are worth mentioning.</P>
<P><B>total_jobs()</B> returns the total number of jobs:</P>
<PRE><CODE>  parallel echo Job {#} of {= '$_=total_jobs()' =} ::: {1..5}</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Job 1 of 5
  Job 2 of 5
  Job 3 of 5
  Job 4 of 5
  Job 5 of 5</CODE></PRE>
<P><B>Q(...)</B> shell quotes the string:</P>
<PRE><CODE>  parallel echo {} shell quoted is {= '$_=Q($_)' =} ::: '*/!#$'</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  */!#$ shell quoted is \*/\!\#\$</CODE></PRE>
<P><B>skip()</B> skips the job:</P>
<PRE><CODE>  parallel echo {= 'if($_==3) { skip() }' =} ::: {1..5}</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  1
  2
  4
  5</CODE></PRE>
<P><B>@arg</B> contains the input source variables:</P>
<PRE><CODE>  parallel echo {= 'if($arg[1]==$arg[2]) { skip() }' =} ::: {1..3} ::: {1..3}</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  1 2
  1 3
  2 1
  2 3
  3 1
  3 2</CODE></PRE>
<P>If the strings <B>{=</B> and <B>=}</B> cause problems they can be replaced 
with <B>--parens</B>:</P>
<PRE><CODE>  parallel --parens ,,,, echo ',, s:\.[^.]+$::;s:\.[^.]+$::; ,,' ::: foo.tar.gz</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  foo</CODE></PRE>
<P>To define a shorthand replacement string use <B>--rpl</B>:</P>
<PRE><CODE>  parallel --rpl '.. s:\.[^.]+$::;s:\.[^.]+$::;' echo '..' ::: foo.tar.gz</CODE></PRE>
<P>Output: Same as above.</P>
<P>If the shorthand starts with <B>{</B> it can be used as a positional 
replacement string, too:</P>
<PRE><CODE>  parallel --rpl '{..} s:\.[^.]+$::;s:\.[^.]+$::;' echo '{..}' ::: foo.tar.gz</CODE></PRE>
<P>Output: Same as above.</P>
<P>GNU <B>parallel</B>'s 7 replacement strings are implemented as this:</P>
<PRE><CODE>  --rpl '{} '
  --rpl '{#} $_=$job-&gt;seq()'
  --rpl '{%} $_=$job-&gt;slot()'
  --rpl '{/} s:.*/::'
  --rpl '{//} $Global::use{"File::Basename"} ||= eval "use File::Basename; 1;"; $_ = dirname($_);'
  --rpl '{/.} s:.*/::; s:\.[^/.]+$::;'
  --rpl '{.} s:\.[^/.]+$::'</CODE></PRE>
<H3 id="Positional-replacement-strings">Positional replacement strings</H3>
<P>With multiple input sources the argument from the individual input sources 
can be accessed with <B>{</B>number<B>}</B>:</P>
<PRE><CODE>  parallel echo {1} and {2} ::: A B ::: C D</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A and C
  A and D
  B and C
  B and D</CODE></PRE>
<P>The positional replacement strings can also be modified using <B>/</B>, 
<B>//</B>, <B>/.</B>, and <B>.</B>:</P>
<PRE><CODE>  parallel echo /={1/} //={1//} /.={1/.} .={1.} ::: A/B.C D/E.F</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  /=B.C //=A /.=B .=A/B
  /=E.F //=D /.=E .=D/E</CODE></PRE>
<P>If a position is negative, it will refer to the input source counted from 
behind:</P>
<PRE><CODE>  parallel echo 1={1} 2={2} 3={3} -1={-1} -2={-2} -3={-3} ::: A B ::: C D ::: E F</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  1=A 2=C 3=E -1=E -2=C -3=A
  1=A 2=C 3=F -1=F -2=C -3=A
  1=A 2=D 3=E -1=E -2=D -3=A
  1=A 2=D 3=F -1=F -2=D -3=A
  1=B 2=C 3=E -1=E -2=C -3=B
  1=B 2=C 3=F -1=F -2=C -3=B
  1=B 2=D 3=E -1=E -2=D -3=B
  1=B 2=D 3=F -1=F -2=D -3=B</CODE></PRE>
<H3 id="Positional-perl-expression-replacement-string">Positional perl 
expression replacement string</H3>
<P>To use a perl expression as a positional replacement string simply prepend 
the perl expression with number and space:</P>
<PRE><CODE>  parallel echo '{=2 s:\.[^.]+$::;s:\.[^.]+$::; =} {1}' ::: bar ::: foo.tar.gz</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  foo bar</CODE></PRE>
<P>If a shorthand defined using <B>--rpl</B> starts with <B>{</B> it can be used 
as a positional replacement string, too:</P>
<PRE><CODE>  parallel --rpl '{..} s:\.[^.]+$::;s:\.[^.]+$::;' echo '{2..} {1}' ::: bar ::: foo.tar.gz</CODE></PRE>
<P>Output: Same as above.</P>
<H3 id="Input-from-columns">Input from columns</H3>
<P>The columns in a file can be bound to positional replacement strings using 
<B>--colsep</B>. Here the columns are separated by TAB (\t):</P>
<PRE><CODE>  parallel --colsep '\t' echo 1={1} 2={2} :::: tsv-file.tsv</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  1=f1 2=f2
  1=A 2=B
  1=C 2=D</CODE></PRE>
<H3 id="Header-defined-replacement-strings">Header defined replacement 
strings</H3>
<P>With <B>--header</B> GNU <B>parallel</B> will use the first value of the 
input source as the name of the replacement string. Only the non-modified 
version <B>{}</B> is supported:</P>
<PRE><CODE>  parallel --header : echo f1={f1} f2={f2} ::: f1 A B ::: f2 C D</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  f1=A f2=C
  f1=A f2=D
  f1=B f2=C
  f1=B f2=D</CODE></PRE>
<P>It is useful with <B>--colsep</B> for processing files with TAB separated 
values:</P>
<PRE><CODE>  parallel --header : --colsep '\t' echo f1={f1} f2={f2} :::: tsv-file.tsv</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  f1=A f2=B
  f1=C f2=D</CODE></PRE>
<H3 id="More-pre-defined-replacement-strings">More pre-defined replacement 
strings</H3>
<P><B>--plus</B> adds the replacement strings <B>{+/} {+.} {+..} {+...} {..} 
{...} {/..} {/...} {##}</B>. The idea being that <B>{+foo}</B> matches the 
opposite of <B>{foo}</B> and <B>{}</B> = <B>{+/}</B>/<B>{/}</B> = 
<B>{.}</B>.<B>{+.}</B> = <B>{+/}</B>/<B>{/.}</B>.<B>{+.}</B> = 
<B>{..}</B>.<B>{+..}</B> = <B>{+/}</B>/<B>{/..}</B>.<B>{+..}</B> = 
<B>{...}</B>.<B>{+...}</B> = <B>{+/}</B>/<B>{/...}</B>.<B>{+...}</B>.</P>
<PRE><CODE>  parallel --plus echo {} ::: dir/sub/file.ext1.ext2.ext3
  parallel --plus echo {+/}/{/} ::: dir/sub/file.ext1.ext2.ext3
  parallel --plus echo {.}.{+.} ::: dir/sub/file.ext1.ext2.ext3
  parallel --plus echo {+/}/{/.}.{+.} ::: dir/sub/file.ext1.ext2.ext3
  parallel --plus echo {..}.{+..} ::: dir/sub/file.ext1.ext2.ext3
  parallel --plus echo {+/}/{/..}.{+..} ::: dir/sub/file.ext1.ext2.ext3
  parallel --plus echo {...}.{+...} ::: dir/sub/file.ext1.ext2.ext3
  parallel --plus echo {+/}/{/...}.{+...} ::: dir/sub/file.ext1.ext2.ext3</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  dir/sub/file.ext1.ext2.ext3</CODE></PRE>
<P><B>{##}</B> is simply the number of jobs:</P>
<PRE><CODE>  parallel --plus echo Job {#} of {##} ::: {1..5}</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Job 1 of 5
  Job 2 of 5
  Job 3 of 5
  Job 4 of 5
  Job 5 of 5</CODE></PRE>
<H2 id="More-than-one-argument">More than one argument</H2>
<P>With <B>--xargs</B> GNU <B>parallel</B> will fit as many arguments as 
possible on a single line:</P>
<PRE><CODE>  cat num30000 | parallel --xargs echo | wc -l</CODE></PRE>
<P>Output (if you run this under Bash on GNU/Linux):</P>
<PRE><CODE>  2</CODE></PRE>
<P>The 30000 arguments fitted on 2 lines.</P>
<P>The maximal length of a single line can be set with <B>-s</B>. With a maximal 
line length of 10000 chars 17 commands will be run:</P>
<PRE><CODE>  cat num30000 | parallel --xargs -s 10000 echo | wc -l</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  17</CODE></PRE>
<P>For better parallelism GNU <B>parallel</B> can distribute the arguments 
between all the parallel jobs when end of file is met.</P>
<P>Below GNU <B>parallel</B> reads the last argument when generating the second 
job. When GNU <B>parallel</B> reads the last argument, it spreads all the 
arguments for the second job over 4 jobs instead, as 4 parallel jobs are 
requested.</P>
<P>The first job will be the same as the <B>--xargs</B> example above, but the 
second job will be split into 4 evenly sized jobs, resulting in a total of 5 
jobs:</P>
<PRE><CODE>  cat num30000 | parallel --jobs 4 -m echo | wc -l</CODE></PRE>
<P>Output (if you run this under Bash on GNU/Linux):</P>
<PRE><CODE>  5</CODE></PRE>
<P>This is even more visible when running 4 jobs with 10 arguments. The 10 
arguments are being spread over 4 jobs:</P>
<PRE><CODE>  parallel --jobs 4 -m echo ::: 1 2 3 4 5 6 7 8 9 10</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  1 2 3
  4 5 6
  7 8 9
  10</CODE></PRE>
<P>A replacement string can be part of a word. <B>-m</B> will not repeat the 
context:</P>
<PRE><CODE>  parallel --jobs 4 -m echo pre-{}-post ::: A B C D E F G</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  pre-A B-post
  pre-C D-post
  pre-E F-post
  pre-G-post</CODE></PRE>
<P>To repeat the context use <B>-X</B> which otherwise works like <B>-m</B>:</P>
<PRE><CODE>  parallel --jobs 4 -X echo pre-{}-post ::: A B C D E F G</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  pre-A-post pre-B-post
  pre-C-post pre-D-post
  pre-E-post pre-F-post
  pre-G-post</CODE></PRE>
<P>To limit the number of arguments use <B>-N</B>:</P>
<PRE><CODE>  parallel -N3 echo ::: A B C D E F G H</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A B C
  D E F
  G H</CODE></PRE>
<P><B>-N</B> also sets the positional replacement strings:</P>
<PRE><CODE>  parallel -N3 echo 1={1} 2={2} 3={3} ::: A B C D E F G H</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  1=A 2=B 3=C
  1=D 2=E 3=F
  1=G 2=H 3=</CODE></PRE>
<P><B>-N0</B> reads 1 argument but inserts none:</P>
<PRE><CODE>  parallel -N0 echo foo ::: 1 2 3</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  foo
  foo
  foo</CODE></PRE>
<H2 id="Quoting">Quoting</H2>
<P>Command lines that contain special characters may need to be protected from 
the shell.</P>
<P>The <B>perl</B> program <B>print "@ARGV\n"</B> basically works like 
<B>echo</B>.</P>
<PRE><CODE>  perl -e 'print "@ARGV\n"' A</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A</CODE></PRE>
<P>To run that in parallel the command needs to be quoted:</P>
<PRE><CODE>  parallel perl -e 'print "@ARGV\n"' ::: This wont work</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  [Nothing]</CODE></PRE>
<P>To quote the command use <B>-q</B>:</P>
<PRE><CODE>  parallel -q perl -e 'print "@ARGV\n"' ::: This works</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  This
  works</CODE></PRE>
<P>Or you can quote the critical part using <B>\'</B>:</P>
<PRE><CODE>  parallel perl -e \''print "@ARGV\n"'\' ::: This works, too</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  This
  works,
  too</CODE></PRE>
<P>GNU <B>parallel</B> can also \-quote full lines. Simply run this:</P>
<PRE><CODE>  parallel --shellquote
  parallel: Warning: Input is read from the terminal. You either know what you
  parallel: Warning: are doing (in which case: YOU ARE AWESOME!) or you forgot
  parallel: Warning: ::: or :::: or to pipe data into parallel. If so
  parallel: Warning: consider going through the tutorial: man parallel_tutorial
  parallel: Warning: Press CTRL-D to exit.
  perl -e 'print "@ARGV\n"'
  [CTRL-D]</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  perl\ -e\ \'print\ \"@ARGV\\n\"\'</CODE></PRE>
<P>This can then be used as the command:</P>
<PRE><CODE>  parallel perl\ -e\ \'print\ \"@ARGV\\n\"\' ::: This also works</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  This
  also
  works</CODE></PRE>
<H2 id="Trimming-space">Trimming space</H2>
<P>Space can be trimmed on the arguments using <B>--trim</B>:</P>
<PRE><CODE>  parallel --trim r echo pre-{}-post ::: ' A '</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  pre- A-post</CODE></PRE>
<P>To trim on the left side:</P>
<PRE><CODE>  parallel --trim l echo pre-{}-post ::: ' A '</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  pre-A -post</CODE></PRE>
<P>To trim on the both sides:</P>
<PRE><CODE>  parallel --trim lr echo pre-{}-post ::: ' A '</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  pre-A-post</CODE></PRE>
<H2 id="Respecting-the-shell">Respecting the shell</H2>
<P>This tutorial uses Bash as the shell. GNU <B>parallel</B> respects which 
shell you are using, so in <B>zsh</B> you can do:</P>
<PRE><CODE>  parallel echo \={} ::: zsh bash ls</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  /usr/bin/zsh
  /bin/bash
  /bin/ls</CODE></PRE>
<P>In <B>csh</B> you can do:</P>
<PRE><CODE>  parallel 'set a="{}"; if( { test -d "$a" } ) echo "$a is a dir"' ::: *</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  [somedir] is a dir</CODE></PRE>
<P>This also becomes useful if you use GNU <B>parallel</B> in a shell script: 
GNU <B>parallel</B> will use the same shell as the shell script.</P>
<H1 id="Controlling-the-output">Controlling the output</H1>
<P>The output can prefixed with the argument:</P>
<PRE><CODE>  parallel --tag echo foo-{} ::: A B C</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A       foo-A
  B       foo-B
  C       foo-C</CODE></PRE>
<P>To prefix it with another string use <B>--tagstring</B>:</P>
<PRE><CODE>  parallel --tagstring {}-bar echo foo-{} ::: A B C</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  A-bar   foo-A
  B-bar   foo-B
  C-bar   foo-C</CODE></PRE>
<P>To see what commands will be run without running them use 
<B>--dryrun</B>:</P>
<PRE><CODE>  parallel --dryrun echo {} ::: A B C</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  echo A
  echo B
  echo C</CODE></PRE>
<P>To print the command before running them use <B>--verbose</B>:</P>
<PRE><CODE>  parallel --verbose echo {} ::: A B C</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  echo A
  echo B
  A
  echo C
  B
  C</CODE></PRE>
<P>GNU <B>parallel</B> will postpone the output until the command completes:</P>
<PRE><CODE>  parallel -j2 'printf "%s-start\n%s" {} {};sleep {};printf "%s\n" -middle;echo {}-end' ::: 4 2 1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  2-start
  2-middle
  2-end
  1-start
  1-middle
  1-end
  4-start
  4-middle
  4-end</CODE></PRE>
<P>To get the output immediately use <B>--ungroup</B>:</P>
<PRE><CODE>  parallel -j2 --ungroup 'printf "%s-start\n%s" {} {};sleep {};printf "%s\n" -middle;echo {}-end' ::: 4 2 1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  4-start
  42-start
  2-middle
  2-end
  1-start
  1-middle
  1-end
  -middle
  4-end</CODE></PRE>
<P><B>--ungroup</B> is fast, but can cause half a line from one job to be mixed 
with half a line of another job. That has happend in the second line, where the 
line '4-middle' is mixed with '2-start'.</P>
<P>To avoid this use <B>--linebuffer</B>:</P>
<PRE><CODE>  parallel -j2 --linebuffer 'printf "%s-start\n%s" {} {};sleep {};printf "%s\n" -middle;echo {}-end' ::: 4 2 1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  4-start
  2-start
  2-middle
  2-end
  1-start
  1-middle
  1-end
  4-middle
  4-end</CODE></PRE>
<P>To force the output in the same order as the arguments use 
<B>--keep-order</B>/<B>-k</B>:</P>
<PRE><CODE>  parallel -j2 -k 'printf "%s-start\n%s" {} {};sleep {};printf "%s\n" -middle;echo {}-end' ::: 4 2 1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  4-start
  4-middle
  4-end
  2-start
  2-middle
  2-end
  1-start
  1-middle
  1-end</CODE></PRE>
<H2 id="Saving-output-into-files">Saving output into files</H2>
<P>GNU <B>parallel</B> can save the output of each job into files:</P>
<PRE><CODE>  parallel --files echo ::: A B C</CODE></PRE>
<P>Output will be similar to this:</P>
<PRE><CODE>  /tmp/pAh6uWuQCg.par
  /tmp/opjhZCzAX4.par
  /tmp/W0AT_Rph2o.par</CODE></PRE>
<P>By default GNU <B>parallel</B> will cache the output in files in <B>/tmp</B>. 
This can be changed by setting <B>$TMPDIR</B> or <B>--tmpdir</B>:</P>
<PRE><CODE>  parallel --tmpdir /var/tmp --files echo ::: A B C</CODE></PRE>
<P>Output will be similar to this:</P>
<PRE><CODE>  /var/tmp/N_vk7phQRc.par
  /var/tmp/7zA4Ccf3wZ.par
  /var/tmp/LIuKgF_2LP.par</CODE></PRE>
<P>Or:</P>
<PRE><CODE>  TMPDIR=/var/tmp parallel --files echo ::: A B C</CODE></PRE>
<P>Output: Same as above.</P>
<P>The output files can be saved in a structured way using <B>--results</B>:</P>
<PRE><CODE>  parallel --results outdir echo ::: A B C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A
  B
  C</CODE></PRE>
<P>These files were also generated containing the standard output (stdout), 
standard error (stderr), and the sequence number (seq):</P>
<PRE><CODE>  outdir/1/A/seq
  outdir/1/A/stderr
  outdir/1/A/stdout
  outdir/1/B/seq
  outdir/1/B/stderr
  outdir/1/B/stdout
  outdir/1/C/seq
  outdir/1/C/stderr
  outdir/1/C/stdout</CODE></PRE>
<P><B>--header :</B> will take the first value as name and use that in the 
directory structure. This is useful if you are using multiple input sources:</P>
<PRE><CODE>  parallel --header : --results outdir echo ::: f1 A B ::: f2 C D</CODE></PRE>
<P>Generated files:</P>
<PRE><CODE>  outdir/f1/A/f2/C/seq
  outdir/f1/A/f2/C/stderr
  outdir/f1/A/f2/C/stdout
  outdir/f1/A/f2/D/seq
  outdir/f1/A/f2/D/stderr
  outdir/f1/A/f2/D/stdout
  outdir/f1/B/f2/C/seq
  outdir/f1/B/f2/C/stderr
  outdir/f1/B/f2/C/stdout
  outdir/f1/B/f2/D/seq
  outdir/f1/B/f2/D/stderr
  outdir/f1/B/f2/D/stdout</CODE></PRE>
<P>The directories are named after the variables and their values.</P>
<H1 id="Controlling-the-execution">Controlling the execution</H1>
<H2 id="Number-of-simultaneous-jobs">Number of simultaneous jobs</H2>
<P>The number of concurrent jobs is given with <B>--jobs</B>/<B>-j</B>:</P>
<PRE><CODE>  /usr/bin/time parallel -N0 -j64 sleep 1 :::: num128</CODE></PRE>
<P>With 64 jobs in parallel the 128 <B>sleep</B>s will take 2-8 seconds to run - 
depending on how fast your machine is.</P>
<P>By default <B>--jobs</B> is the same as the number of CPU cores. So this:</P>
<PRE><CODE>  /usr/bin/time parallel -N0 sleep 1 :::: num128</CODE></PRE>
<P>should take twice the time of running 2 jobs per CPU core:</P>
<PRE><CODE>  /usr/bin/time parallel -N0 --jobs 200% sleep 1 :::: num128</CODE></PRE>
<P><B>--jobs 0</B> will run as many jobs in parallel as possible:</P>
<PRE><CODE>  /usr/bin/time parallel -N0 --jobs 0 sleep 1 :::: num128</CODE></PRE>
<P>which should take 1-7 seconds depending on how fast your machine is.</P>
<P><B>--jobs</B> can read from a file which is re-read when a job finishes:</P>
<PRE><CODE>  echo 50% &gt; my_jobs
  /usr/bin/time parallel -N0 --jobs my_jobs sleep 1 :::: num128 &amp;
  sleep 1
  echo 0 &gt; my_jobs
  wait</CODE></PRE>
<P>The first second only 50% of the CPU cores will run a job. Then <B>0</B> is 
put into <B>my_jobs</B> and then the rest of the jobs will be started in 
parallel.</P>
<P>Instead of basing the percentage on the number of CPU cores GNU 
<B>parallel</B> can base it on the number of CPUs:</P>
<PRE><CODE>  parallel --use-cpus-instead-of-cores -N0 sleep 1 :::: num8</CODE></PRE>
<H2 id="Shuffle-job-order">Shuffle job order</H2>
<P>If you have many jobs (e.g. by multiple combinations of input sources), it 
can be handy to shuffle the jobs, so you get different values run. Use 
<B>--shuf</B> for that:</P>
<PRE><CODE>  parallel --shuf echo ::: 1 2 3 ::: a b c ::: A B C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  All combinations but different order for each run.</CODE></PRE>
<H2 id="Interactivity">Interactivity</H2>
<P>GNU <B>parallel</B> can ask the user if a command should be run using 
<B>--interactive</B>:</P>
<PRE><CODE>  parallel --interactive echo ::: 1 2 3</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  echo 1 ?...y
  echo 2 ?...n
  1
  echo 3 ?...y
  3</CODE></PRE>
<P>GNU <B>parallel</B> can be used to put arguments on the command line for an 
interactive command such as <B>emacs</B> to edit one file at a time:</P>
<PRE><CODE>  parallel --tty emacs ::: 1 2 3</CODE></PRE>
<P>Or give multiple argument in one go to open multiple files:</P>
<PRE><CODE>  parallel -X --tty vi ::: 1 2 3</CODE></PRE>
<H2 id="A-terminal-for-every-job">A terminal for every job</H2>
<P>Using <B>--tmux</B> GNU <B>parallel</B> can start a terminal for every job 
run:</P>
<PRE><CODE>  seq 10 20 | parallel --tmux 'echo start {}; sleep {}; echo done {}'</CODE></PRE>
<P>This will tell you to run something similar to:</P>
<PRE><CODE>  tmux -S /tmp/tmsrPrO0 attach</CODE></PRE>
<P>Using normal <B>tmux</B> keystrokes (CTRL-b n or CTRL-b p) you can cycle 
between windows of the running jobs. When a job is finished it will pause for 10 
seconds before closing the window.</P>
<H2 id="Timing">Timing</H2>
<P>Some jobs do heavy I/O when they start. To avoid a thundering herd GNU 
<B>parallel</B> can delay starting new jobs. <B>--delay</B> <I>X</I> will make 
sure there is at least <I>X</I> seconds between each start:</P>
<PRE><CODE>  parallel --delay 2.5 echo Starting {}\;date ::: 1 2 3</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Starting 1
  Thu Aug 15 16:24:33 CEST 2013
  Starting 2
  Thu Aug 15 16:24:35 CEST 2013
  Starting 3
  Thu Aug 15 16:24:38 CEST 2013</CODE></PRE>
<P>If jobs taking more than a certain amount of time are known to fail, they can 
be stopped with <B>--timeout</B>. The accuracy of <B>--timeout</B> is 2 
seconds:</P>
<PRE><CODE>  parallel --timeout 4.1 sleep {}\; echo {} ::: 2 4 6 8</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  2
  4</CODE></PRE>
<P>GNU <B>parallel</B> can compute the median runtime for jobs and kill those 
that take more than 200% of the median runtime:</P>
<PRE><CODE>  parallel --timeout 200% sleep {}\; echo {} ::: 2.1 2.2 3 7 2.3</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  2.1
  2.2
  3
  2.3</CODE></PRE>
<H2 id="Progress-information">Progress information</H2>
<P>Based on the runtime of completed jobs GNU <B>parallel</B> can estimate the 
total runtime:</P>
<PRE><CODE>  parallel --eta sleep ::: 1 3 2 2 1 3 3 2 1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Computers / CPU cores / Max jobs to run
  1:local / 2 / 2

  Computer:jobs running/jobs completed/%of started jobs/Average seconds to complete
  ETA: 2s 0left 1.11avg  local:0/9/100%/1.1s</CODE></PRE>
<P>GNU <B>parallel</B> can give progress information with <B>--progress</B>:</P>
<PRE><CODE>  parallel --progress sleep ::: 1 3 2 2 1 3 3 2 1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Computers / CPU cores / Max jobs to run
  1:local / 2 / 2

  Computer:jobs running/jobs completed/%of started jobs/Average seconds to complete
  local:0/9/100%/1.1s</CODE></PRE>
<P>A progress bar can be shown with <B>--bar</B>:</P>
<PRE><CODE>  parallel --bar sleep ::: 1 3 2 2 1 3 3 2 1</CODE></PRE>
<P>And a graphic bar can be shown with <B>--bar</B> and <B>zenity</B>:</P>
<PRE><CODE>  seq 1000 | parallel -j10 --bar '(echo -n {};sleep 0.1)' 2&gt; &gt;(zenity --progress --auto-kill --auto-close)</CODE></PRE>
<P>A logfile of the jobs completed so far can be generated with 
<B>--joblog</B>:</P>
<PRE><CODE>  parallel --joblog /tmp/log exit  ::: 1 2 3 0
  cat /tmp/log</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Seq     Host    Starttime       Runtime Send    Receive Exitval Signal  Command
  1       :       1376577364.974  0.008   0       0       1       0       exit 1
  2       :       1376577364.982  0.013   0       0       2       0       exit 2
  3       :       1376577364.990  0.013   0       0       3       0       exit 3
  4       :       1376577365.003  0.003   0       0       0       0       exit 0</CODE></PRE>
<P>The log contains the job sequence, which host the job was run on, the start 
time and run time, how much data was transferred, the exit value, the signal 
that killed the job, and finally the command being run.</P>
<P>With a joblog GNU <B>parallel</B> can be stopped and later pickup where it 
left off. It it important that the input of the completed jobs is unchanged.</P>
<PRE><CODE>  parallel --joblog /tmp/log exit  ::: 1 2 3 0
  cat /tmp/log
  parallel --resume --joblog /tmp/log exit  ::: 1 2 3 0 0 0
  cat /tmp/log</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Seq     Host    Starttime       Runtime Send    Receive Exitval Signal  Command
  1       :       1376580069.544  0.008   0       0       1       0       exit 1
  2       :       1376580069.552  0.009   0       0       2       0       exit 2
  3       :       1376580069.560  0.012   0       0       3       0       exit 3
  4       :       1376580069.571  0.005   0       0       0       0       exit 0

  Seq     Host    Starttime       Runtime Send    Receive Exitval Signal  Command
  1       :       1376580069.544  0.008   0       0       1       0       exit 1
  2       :       1376580069.552  0.009   0       0       2       0       exit 2
  3       :       1376580069.560  0.012   0       0       3       0       exit 3
  4       :       1376580069.571  0.005   0       0       0       0       exit 0
  5       :       1376580070.028  0.009   0       0       0       0       exit 0
  6       :       1376580070.038  0.007   0       0       0       0       exit 0</CODE></PRE>
<P>Note how the start time of the last 2 jobs is clearly different from the 
second run.</P>
<P>With <B>--resume-failed</B> GNU <B>parallel</B> will re-run the jobs that 
failed:</P>
<PRE><CODE>  parallel --resume-failed --joblog /tmp/log exit  ::: 1 2 3 0 0 0
  cat /tmp/log</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Seq     Host    Starttime       Runtime Send    Receive Exitval Signal  Command
  1       :       1376580069.544  0.008   0       0       1       0       exit 1
  2       :       1376580069.552  0.009   0       0       2       0       exit 2
  3       :       1376580069.560  0.012   0       0       3       0       exit 3
  4       :       1376580069.571  0.005   0       0       0       0       exit 0
  5       :       1376580070.028  0.009   0       0       0       0       exit 0
  6       :       1376580070.038  0.007   0       0       0       0       exit 0
  1       :       1376580154.433  0.010   0       0       1       0       exit 1
  2       :       1376580154.444  0.022   0       0       2       0       exit 2
  3       :       1376580154.466  0.005   0       0       3       0       exit 3</CODE></PRE>
<P>Note how seq 1 2 3 have been repeated because they had exit value different 
from 0.</P>
<P><B>--retry-failed</B> does almost the same as <B>--resume-failed</B>. Where 
<B>--resume-failed</B> reads the commands from the command line (and ignores the 
commands in the joblog), <B>--retry-failed</B> ignores the command line and 
reruns the commands mentioned in the joblog.</P>
<PRE><CODE>  parallel --retry-failed --joblog /tmp/log
  cat /tmp/log</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Seq     Host    Starttime       Runtime Send    Receive Exitval Signal  Command
  1       :       1376580069.544  0.008   0       0       1       0       exit 1
  2       :       1376580069.552  0.009   0       0       2       0       exit 2
  3       :       1376580069.560  0.012   0       0       3       0       exit 3
  4       :       1376580069.571  0.005   0       0       0       0       exit 0
  5       :       1376580070.028  0.009   0       0       0       0       exit 0
  6       :       1376580070.038  0.007   0       0       0       0       exit 0
  1       :       1376580154.433  0.010   0       0       1       0       exit 1
  2       :       1376580154.444  0.022   0       0       2       0       exit 2
  3       :       1376580154.466  0.005   0       0       3       0       exit 3
  1       :       1376580164.633  0.010   0       0       1       0       exit 1
  2       :       1376580164.644  0.022   0       0       2       0       exit 2
  3       :       1376580164.666  0.005   0       0       3       0       exit 3</CODE></PRE>
<H2 id="Termination">Termination</H2>
<P>For certain jobs there is no need to continue if one of the jobs fails and 
has an exit code different from 0. GNU <B>parallel</B> will stop spawning new 
jobs with <B>--halt soon,fail=1</B>:</P>
<PRE><CODE>  parallel -j2 --halt soon,fail=1 echo {}\; exit {} ::: 0 0 1 2 3</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  0
  0
  1
  parallel: Starting no more jobs. Waiting for 2 jobs to finish. This job failed:
  echo 1; exit 1
  2
  parallel: Starting no more jobs. Waiting for 1 jobs to finish. This job failed:
  echo 2; exit 2</CODE></PRE>
<P>With <B>--halt now,fail=1</B> the running jobs will be killed 
immediately:</P>
<PRE><CODE>  parallel -j2 --halt now,fail=1 echo {}\; exit {} ::: 0 0 1 2 3</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  0
  0
  1
  parallel: This job failed:
  echo 1; exit 1</CODE></PRE>
<P>If <B>--halt</B> is given a percentage this percentage of the jobs must fail 
before GNU <B>parallel</B> stops spawning more jobs:</P>
<PRE><CODE>  parallel -j2 --halt soon,fail=20% echo {}\; exit {} ::: 0 1 2 3 4 5 6 7 8 9</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  0
  1
  parallel: This job failed:
  echo 1; exit 1
  2
  parallel: This job failed:
  echo 2; exit 2
  parallel: Starting no more jobs. Waiting for 1 jobs to finish.
  3
  parallel: This job failed:
  echo 3; exit 3</CODE></PRE>
<P>If you are looking for success instead of failures, you can use 
<B>success</B>. This will finish as soon as the first job succeeds:</P>
<PRE><CODE>  parallel -j2 --halt now,success=1 echo {}\; exit {} ::: 1 2 3 0 4 5 6</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  1
  2
  3
  0
  parallel: This job succeeded:
  echo 0; exit 0</CODE></PRE>
<P>GNU <B>parallel</B> can retry the command with <B>--retries</B>. This is 
useful if a command fails for unknown reasons now and then.</P>
<PRE><CODE>  parallel -k --retries 3 'echo tried {} &gt;&gt;/tmp/runs; echo completed {}; exit {}' ::: 1 2 0
  cat /tmp/runs</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  completed 1
  completed 2
  completed 0

  tried 1
  tried 2
  tried 1
  tried 2
  tried 1
  tried 2
  tried 0</CODE></PRE>
<P>Note how job 1 and 2 were tried 3 times, but 0 was not retried because it had 
exit code 0.</P>
<H3 id="Termination-signals-advanced">Termination signals (advanced)</H3>
<P>Using <B>--termseq</B> you can control which signals are sent when killing 
children. Normally children will be killed by sending them <B>SIGTERM</B>, 
waiting 200 ms, then another <B>SIGTERM</B>, waiting 100 ms, then another 
<B>SIGTERM</B>, waiting 50 ms, then a <B>SIGKILL</B>, finally waiting 25 ms 
before giving up. It looks like this:</P>
<PRE><CODE>  show_signals() {
    perl -e 'for(keys %SIG) { $SIG{$_} = eval "sub { print \"Got $_\\n\"; }";} while(1){sleep 1}'
  }
  export -f show_signals
  echo | parallel --termseq TERM,200,TERM,100,TERM,50,KILL,25 -u --timeout 1 show_signals</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Got TERM
  Got TERM
  Got TERM</CODE></PRE>
<P>Or just:</P>
<PRE><CODE>  echo | parallel -u --timeout 1 show_signals</CODE></PRE>
<P>Output: Same as above.</P>
<P>You can change this to <B>SIGINT</B>, <B>SIGTERM</B>, <B>SIGKILL</B>:</P>
<PRE><CODE>  echo | parallel --termseq INT,200,TERM,100,KILL,25 -u --timeout 1 show_signals</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Got INT
  Got TERM</CODE></PRE>
<P>The <B>SIGKILL</B> does not show because it cannot be caught, and thus the 
child dies.</P>
<H2 id="Limiting-the-resources">Limiting the resources</H2>
<P>To avoid overloading systems GNU <B>parallel</B> can look at the system load 
before starting another job:</P>
<PRE><CODE>  parallel --load 100% echo load is less than {} job per cpu ::: 1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  [when then load is less than the number of cpu cores]
  load is less than 1 job per cpu</CODE></PRE>
<P>GNU <B>parallel</B> can also check if the system is swapping.</P>
<PRE><CODE>  parallel --noswap echo the system is not swapping ::: now</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  [when then system is not swapping]
  the system is not swapping now</CODE></PRE>
<P>Some jobs need a lot of memory, and should only be started when there is 
enough memory free. Using <B>--memfree</B> GNU <B>parallel</B> can check if 
there is enough memory free. Additionally, GNU <B>parallel</B> will kill off the 
youngest job if the memory free falls below 50% of the size. The killed job will 
put back on the queue and retried later.</P>
<PRE><CODE>  parallel --memfree 1G echo will run if more than 1 GB is ::: free</CODE></PRE>
<P>GNU <B>parallel</B> can run the jobs with a nice value. This will work both 
locally and remotely.</P>
<PRE><CODE>  parallel --nice 17 echo this is being run with nice -n ::: 17</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  this is being run with nice -n 17</CODE></PRE>
<H1 id="Remote-execution">Remote execution</H1>
<P>GNU <B>parallel</B> can run jobs on remote servers. It uses <B>ssh</B> to 
communicate with the remote machines.</P>
<H2 id="Sshlogin">Sshlogin</H2>
<P>The most basic sshlogin is <B>-S</B> <I>host</I>:</P>
<PRE><CODE>  parallel -S $SERVER1 echo running on ::: $SERVER1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  running on [$SERVER1]</CODE></PRE>
<P>To use a different username prepend the server with <I>username@</I>:</P>
<PRE><CODE>  parallel -S username@$SERVER1 echo running on ::: username@$SERVER1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  running on [username@$SERVER1]</CODE></PRE>
<P>The special sshlogin <B>:</B> is the local machine:</P>
<PRE><CODE>  parallel -S : echo running on ::: the_local_machine</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  running on the_local_machine</CODE></PRE>
<P>If <B>ssh</B> is not in $PATH it can be prepended to $SERVER1:</P>
<PRE><CODE>  parallel -S '/usr/bin/ssh '$SERVER1 echo custom ::: ssh</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  custom ssh</CODE></PRE>
<P>The <B>ssh</B> command can also be given using <B>--ssh</B>:</P>
<PRE><CODE>  parallel --ssh /usr/bin/ssh -S $SERVER1 echo custom ::: ssh</CODE></PRE>
<P>or by setting <B>$PARALLEL_SSH</B>:</P>
<PRE><CODE>  export PARALLEL_SSH=/usr/bin/ssh
  parallel -S $SERVER1 echo custom ::: ssh</CODE></PRE>
<P>Several servers can be given using multiple <B>-S</B>:</P>
<PRE><CODE>  parallel -S $SERVER1 -S $SERVER2 echo ::: running on more hosts</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  running
  on
  more
  hosts</CODE></PRE>
<P>Or they can be separated by <B>,</B>:</P>
<PRE><CODE>  parallel -S $SERVER1,$SERVER2 echo ::: running on more hosts</CODE></PRE>
<P>Output: Same as above.</P>
<P>Or newline:</P>
<PRE><CODE>  # This gives a \n between $SERVER1 and $SERVER2
  SERVERS="`echo $SERVER1; echo $SERVER2`"
  parallel -S "$SERVERS" echo ::: running on more hosts</CODE></PRE>
<P>They can also be read from a file (replace <I>user@</I> with the user on 
<B>$SERVER2</B>):</P>
<PRE><CODE>  echo $SERVER1 &gt; nodefile
  # Force 4 cores, special ssh-command, username
  echo 4//usr/bin/ssh user@$SERVER2 &gt;&gt; nodefile
  parallel --sshloginfile nodefile echo ::: running on more hosts</CODE></PRE>
<P>Output: Same as above.</P>
<P>Every time a job finished, the <B>--sshloginfile</B> will be re-read, so it 
is possible to both add and remove hosts while running.</P>
<P>The special <B>--sshloginfile ..</B> reads from 
<B>~/.parallel/sshloginfile</B>.</P>
<P>To force GNU <B>parallel</B> to treat a server having a given number of CPU 
cores prepend the number of core followed by <B>/</B> to the sshlogin:</P>
<PRE><CODE>  parallel -S 4/$SERVER1 echo force {} cpus on server ::: 4</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  force 4 cpus on server</CODE></PRE>
<P>Servers can be put into groups by prepending <I>@groupname</I> to the server 
and the group can then be selected by appending <I>@groupname</I> to the 
argument if using <B>--hostgroup</B>:</P>
<PRE><CODE>  parallel --hostgroup -S @grp1/$SERVER1 -S @grp2/$SERVER2 echo {} ::: \
    run_on_grp1@grp1 run_on_grp2@grp2</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  run_on_grp1
  run_on_grp2</CODE></PRE>
<P>A host can be in multiple groups by separating the groups with <B>+</B>, and 
you can force GNU <B>parallel</B> to limit the groups on which the command can 
be run with <B>-S</B> <I>@groupname</I>:</P>
<PRE><CODE>  parallel -S @grp1 -S @grp1+grp2/$SERVER1 -S @grp2/SERVER2 echo {} ::: \
    run_on_grp1 also_grp1</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  run_on_grp1
  also_grp1</CODE></PRE>
<H2 id="Transferring-files">Transferring files</H2>
<P>GNU <B>parallel</B> can transfer the files to be processed to the remote 
host. It does that using rsync.</P>
<PRE><CODE>  echo This is input_file &gt; input_file
  parallel -S $SERVER1 --transferfile {} cat ::: input_file</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  This is input_file</CODE></PRE>
<P>If the files are processed into another file, the resulting file can be 
transferred back:</P>
<PRE><CODE>  echo This is input_file &gt; input_file
  parallel -S $SERVER1 --transferfile {} --return {}.out cat {} "&gt;"{}.out ::: input_file
  cat input_file.out</CODE></PRE>
<P>Output: Same as above.</P>
<P>To remove the input and output file on the remote server use 
<B>--cleanup</B>:</P>
<PRE><CODE>  echo This is input_file &gt; input_file
  parallel -S $SERVER1 --transferfile {} --return {}.out --cleanup cat {} "&gt;"{}.out ::: input_file
  cat input_file.out</CODE></PRE>
<P>Output: Same as above.</P>
<P>There is a shorthand for <B>--transferfile {} --return --cleanup</B> called 
<B>--trc</B>:</P>
<PRE><CODE>  echo This is input_file &gt; input_file
  parallel -S $SERVER1 --trc {}.out cat {} "&gt;"{}.out ::: input_file
  cat input_file.out</CODE></PRE>
<P>Output: Same as above.</P>
<P>Some jobs need a common database for all jobs. GNU <B>parallel</B> can 
transfer that using <B>--basefile</B> which will transfer the file before the 
first job:</P>
<PRE><CODE>  echo common data &gt; common_file
  parallel --basefile common_file -S $SERVER1 cat common_file\; echo {} ::: foo</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  common data
  foo</CODE></PRE>
<P>To remove it from the remote host after the last job use 
<B>--cleanup</B>.</P>
<H2 id="Working-dir">Working dir</H2>
<P>The default working dir on the remote machines is the login dir. This can be 
changed with <B>--workdir</B> <I>mydir</I>.</P>
<P>Files transferred using <B>--transferfile</B> and <B>--return</B> will be 
relative to <I>mydir</I> on remote computers, and the command will be executed 
in the dir <I>mydir</I>.</P>
<P>The special <I>mydir</I> value <B>...</B> will create working dirs under 
<B>~/.parallel/tmp</B> on the remote computers. If <B>--cleanup</B> is given 
these dirs will be removed.</P>
<P>The special <I>mydir</I> value <B>.</B> uses the current working dir. If the 
current working dir is beneath your home dir, the value <B>.</B> is treated as 
the relative path to your home dir. This means that if your home dir is 
different on remote computers (e.g. if your login is different) the relative 
path will still be relative to your home dir.</P>
<PRE><CODE>  parallel -S $SERVER1 pwd ::: ""
  parallel --workdir . -S $SERVER1 pwd ::: ""
  parallel --workdir ... -S $SERVER1 pwd ::: ""</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  [the login dir on $SERVER1]
  [current dir relative on $SERVER1]
  [a dir in ~/.parallel/tmp/...]</CODE></PRE>
<H2 id="Avoid-overloading-sshd">Avoid overloading sshd</H2>
<P>If many jobs are started on the same server, <B>sshd</B> can be overloaded. 
GNU <B>parallel</B> can insert a delay between each job run on the same 
server:</P>
<PRE><CODE>  parallel -S $SERVER1 --sshdelay 0.2 echo ::: 1 2 3</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  1
  2
  3</CODE></PRE>
<P><B>sshd</B> will be less overloaded if using <B>--controlmaster</B>, which 
will multiplex ssh connections:</P>
<PRE><CODE>  parallel --controlmaster -S $SERVER1 echo ::: 1 2 3</CODE></PRE>
<P>Output: Same as above.</P>
<H2 id="Ignore-hosts-that-are-down">Ignore hosts that are down</H2>
<P>In clusters with many hosts a few of them are often down. GNU <B>parallel</B> 
can ignore those hosts. In this case the host 173.194.32.46 is down:</P>
<PRE><CODE>  parallel --filter-hosts -S 173.194.32.46,$SERVER1 echo ::: bar</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  bar</CODE></PRE>
<H2 id="Running-the-same-commands-on-all-hosts">Running the same commands on all 
hosts</H2>
<P>GNU <B>parallel</B> can run the same command on all the hosts:</P>
<PRE><CODE>  parallel --onall -S $SERVER1,$SERVER2 echo ::: foo bar</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  foo
  bar
  foo
  bar</CODE></PRE>
<P>Often you will just want to run a single command on all hosts with out 
arguments. <B>--nonall</B> is a no argument <B>--onall</B>:</P>
<PRE><CODE>  parallel --nonall -S $SERVER1,$SERVER2 echo foo bar</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  foo bar
  foo bar</CODE></PRE>
<P>When <B>--tag</B> is used with <B>--nonall</B> and <B>--onall</B> the 
<B>--tagstring</B> is the host:</P>
<PRE><CODE>  parallel --nonall --tag -S $SERVER1,$SERVER2 echo foo bar</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  $SERVER1 foo bar
  $SERVER2 foo bar</CODE></PRE>
<P><B>--jobs</B> sets the number of servers to log in to in parallel.</P>
<H2 id="Transferring-environment-variables-and-functions">Transferring 
environment variables and functions</H2>
<P><B>env_parallel</B> is a shell function that transfers all aliases, 
functions, variables, and arrays. You active it by running:</P>
<PRE><CODE>  source `which env_parallel.bash`</CODE></PRE>
<P>Replace <B>bash</B> with the shell you use.</P>
<P>Now you can use <B>env_parallel</B> instead of <B>parallel</B> and still have 
your environment:</P>
<PRE><CODE>  alias myecho=echo
  myvar="Joe's var is"
  env_parallel -S $SERVER1 'myecho $myvar' ::: green</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Joe's var is green</CODE></PRE>
<P>The disadvantage is that if your environment is huge <B>env_parallel</B> will 
fail.</P>
<P>When <B>env_parallel</B> fails, you can still use <B>--env</B> to tell GNU 
<B>parallel</B> to transfer an environment variable to the remote system.</P>
<PRE><CODE>  MYVAR='foo bar'
  export MYVAR
  parallel --env MYVAR -S $SERVER1 echo '$MYVAR' ::: baz</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  foo bar baz</CODE></PRE>
<P>This works for functions, too, if your shell is Bash:</P>
<PRE><CODE>  # This only works in Bash
  my_func() {
    echo in my_func $1
  }
  export -f my_func
  parallel --env my_func -S $SERVER1 my_func ::: baz</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  in my_func baz</CODE></PRE>
<P>GNU <B>parallel</B> can copy all defined variables and functions to the 
remote system. It just needs to record which ones to ignore in 
<B>~/.parallel/ignored_vars</B>. Do that by running this once:</P>
<PRE><CODE>  parallel --record-env
  cat ~/.parallel/ignored_vars</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  [list of variables to ignore - including $PATH and $HOME]</CODE></PRE>
<P>Now all new variables and functions defined will be copied when using 
<B>--env _</B>:</P>
<PRE><CODE>  # The function is only copied if using Bash
  my_func2() {
    echo in my_func2 $VAR $1
  }
  export -f my_func2
  VAR=foo
  export VAR

  parallel --env _ -S $SERVER1 'echo $VAR; my_func2' ::: bar</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  foo
  in my_func2 foo bar</CODE></PRE>
<H2 id="Showing-what-is-actually-run">Showing what is actually run</H2>
<P><B>--verbose</B> will show the command that would be run on the local 
machine.</P>
<P>When using <B>--cat</B>, <B>--pipepart</B>, or when a job is run on a remote 
machine, the command is wrapped with helper scripts. <B>-vv</B> shows all of 
this.</P>
<PRE><CODE>  parallel -vv --pipepart --block 1M wc :::: num30000</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  &lt;num30000 perl -e 'while(@ARGV) { sysseek(STDIN,shift,0) || die;
  $left = shift; while($read = sysread(STDIN,$buf, ($left &gt; 131072
  ? 131072 : $left))){ $left -= $read; syswrite(STDOUT,$buf); } }'
  0 0 0 168894 | (wc)
    30000   30000  168894</CODE></PRE>
<P>When the command gets more complex, the output is so hard to read, that it is 
only useful for debugging:</P>
<PRE><CODE>  my_func3() {
    echo in my_func $1 &gt; $1.out
  }
  export -f my_func3
  parallel -vv --workdir ... --nice 17 --env _ --trc {}.out -S $SERVER1 my_func3 {} ::: abc-file</CODE></PRE>
<P>Output will be similar to:</P>
<PRE><CODE>  ( ssh server -- mkdir -p ./.parallel/tmp/aspire-1928520-1;rsync
  --protocol 30 -rlDzR -essh ./abc-file 
  server:./.parallel/tmp/aspire-1928520-1 );ssh server -- exec perl -e 
  \''@GNU_Parallel=("use","IPC::Open3;","use","MIME::Base64");
  eval"@GNU_Parallel";my$eval=decode_base64(join"",@ARGV);eval$eval;'\'
  c3lzdGVtKCJta2RpciIsIi1wIiwiLS0iLCIucGFyYWxsZWwvdG1wL2FzcGlyZS0xOTI4N
  TsgY2hkaXIgIi5wYXJhbGxlbC90bXAvYXNwaXJlLTE5Mjg1MjAtMSIgfHxwcmludChTVE
  BhcmFsbGVsOiBDYW5ub3QgY2hkaXIgdG8gLnBhcmFsbGVsL3RtcC9hc3BpcmUtMTkyODU
  iKSAmJiBleGl0IDI1NTskRU5WeyJPTERQV0QifT0iL2hvbWUvdGFuZ2UvcHJpdmF0L3Bh
  IjskRU5WeyJQQVJBTExFTF9QSUQifT0iMTkyODUyMCI7JEVOVnsiUEFSQUxMRUxfU0VRI
  0BiYXNoX2Z1bmN0aW9ucz1xdyhteV9mdW5jMyk7IGlmKCRFTlZ7IlNIRUxMIn09fi9jc2
  ByaW50IFNUREVSUiAiQ1NIL1RDU0ggRE8gTk9UIFNVUFBPUlQgbmV3bGluZXMgSU4gVkF
  TL0ZVTkNUSU9OUy4gVW5zZXQgQGJhc2hfZnVuY3Rpb25zXG4iOyBleGVjICJmYWxzZSI7
  YXNoZnVuYyA9ICJteV9mdW5jMygpIHsgIGVjaG8gaW4gbXlfZnVuYyBcJDEgPiBcJDEub
  Xhwb3J0IC1mIG15X2Z1bmMzID4vZGV2L251bGw7IjtAQVJHVj0ibXlfZnVuYzMgYWJjLW
  RzaGVsbD0iJEVOVntTSEVMTH0iOyR0bXBkaXI9Ii90bXAiOyRuaWNlPTE3O2RveyRFTlZ
  MRUxfVE1QfT0kdG1wZGlyLiIvcGFyIi5qb2luIiIsbWFweygwLi45LCJhIi4uInoiLCJB
  KVtyYW5kKDYyKV19KDEuLjUpO313aGlsZSgtZSRFTlZ7UEFSQUxMRUxfVE1QfSk7JFNJ
  fT1zdWJ7JGRvbmU9MTt9OyRwaWQ9Zm9yazt1bmxlc3MoJHBpZCl7c2V0cGdycDtldmFse
  W9yaXR5KDAsMCwkbmljZSl9O2V4ZWMkc2hlbGwsIi1jIiwoJGJhc2hmdW5jLiJAQVJHVi
  JleGVjOiQhXG4iO31kb3skcz0kczwxPzAuMDAxKyRzKjEuMDM6JHM7c2VsZWN0KHVuZGV
  mLHVuZGVmLCRzKTt9dW50aWwoJGRvbmV8fGdldHBwaWQ9PTEpO2tpbGwoU0lHSFVQLC0k
  dW5sZXNzJGRvbmU7d2FpdDtleGl0KCQ/JjEyNz8xMjgrKCQ/JjEyNyk6MSskPz4+OCk=;
  _EXIT_status=$?; mkdir -p ./.; rsync --protocol 30 --rsync-path=cd\
  ./.parallel/tmp/aspire-1928520-1/./.\;\ rsync -rlDzR -essh
  server:./abc-file.out ./.;ssh server -- \(rm\ -f\
  ./.parallel/tmp/aspire-1928520-1/abc-file\;\ sh\ -c\ \'rmdir\
  ./.parallel/tmp/aspire-1928520-1/\ ./.parallel/tmp/\ ./.parallel/\
  2\&gt;/dev/null\'\;rm\ -rf\ ./.parallel/tmp/aspire-1928520-1\;\);ssh
  server -- \(rm\ -f\ ./.parallel/tmp/aspire-1928520-1/abc-file.out\;\
  sh\ -c\ \'rmdir\ ./.parallel/tmp/aspire-1928520-1/\ ./.parallel/tmp/\
  ./.parallel/\ 2\&gt;/dev/null\'\;rm\ -rf\ 
  ./.parallel/tmp/aspire-1928520-1\;\);ssh server -- rm -rf 
  .parallel/tmp/aspire-1928520-1; exit $_EXIT_status;</CODE></PRE>
<H1 id="Saving-to-an-SQL-base-advanced">Saving to an SQL base (advanced)</H1>
<P>GNU <B>parallel</B> can save into an SQL base. Point GNU <B>parallel</B> to a 
table and it will put the joblog there together with the variables and the 
output each in their own column.</P>
<H2 id="CSV-as-SQL-base">CSV as SQL base</H2>
<P>The simplest is to use a CSV file as the storage table:</P>
<PRE><CODE>  parallel --sqlandworker csv:////%2Ftmp%2Flog.csv seq ::: 10 ::: 12 13 14
  cat /tmp/log.csv</CODE></PRE>
<P>Note how '/' in the path must be written as %2F.</P>
<P>Output will be similar to:</P>
<PRE><CODE>  Seq,Host,Starttime,JobRuntime,Send,Receive,Exitval,_Signal,Command,V1,V2,Stdout,Stderr
  1,:,1458254498.254,0.069,0,9,0,0,"seq 10 12",10,12,"10
  11
  12
  ",
  2,:,1458254498.278,0.080,0,12,0,0,"seq 10 13",10,13,"10
  11
  12
  13
  ",
  3,:,1458254498.301,0.083,0,15,0,0,"seq 10 14",10,14,"10
  11
  12
  13
  14
  ",</CODE></PRE>
<P>A proper CSV reader (like LibreOffice or R's read.csv) will read this format 
correctly - even with fields containing newlines as above.</P>
<P>If the output is big you may want to put it into files using 
<B>--results</B>:</P>
<PRE><CODE>  parallel --results outdir --sqlandworker csv:////%2Ftmp%2Flog2.csv seq ::: 10 ::: 12 13 14
  cat /tmp/log2.csv</CODE></PRE>
<P>Output will be similar to:</P>
<PRE><CODE>  Seq,Host,Starttime,JobRuntime,Send,Receive,Exitval,_Signal,Command,V1,V2,Stdout,Stderr
  1,:,1458824738.287,0.029,0,9,0,0,"seq 10 12",10,12,outdir/1/10/2/12/stdout,outdir/1/10/2/12/stderr
  2,:,1458824738.298,0.025,0,12,0,0,"seq 10 13",10,13,outdir/1/10/2/13/stdout,outdir/1/10/2/13/stderr
  3,:,1458824738.309,0.026,0,15,0,0,"seq 10 14",10,14,outdir/1/10/2/14/stdout,outdir/1/10/2/14/stderr</CODE></PRE>
<H2 id="DBURL-as-table">DBURL as table</H2>
<P>The CSV file is an example of a DBURL.</P>
<P>GNU <B>parallel</B> uses a DBURL to address the table. A DBURL has this 
format:</P>
<PRE><CODE>  vendor://[[user][:password]@][host][:port]/[database[/table]</CODE></PRE>
<P>Example:</P>
<PRE><CODE>  mysql://scott:tiger@my.example.com/mydatabase/mytable
  postgresql://scott:tiger@pg.example.com/mydatabase/mytable
  sqlite3:///%2Ftmp%2Fmydatabase/mytable
  csv:////%2Ftmp%2Flog.csv</CODE></PRE>
<P>To refer to <B>/tmp/mydatabase</B> with <B>sqlite</B> or <B>csv</B> you need 
to encode the <B>/</B> as <B>%2F</B>.</P>
<P>Run a job using <B>sqlite</B> on <B>mytable</B> in 
<B>/tmp/mydatabase</B>:</P>
<PRE><CODE>  DBURL=sqlite3:///%2Ftmp%2Fmydatabase
  DBURLTABLE=$DBURL/mytable
  parallel --sqlandworker $DBURLTABLE echo ::: foo bar ::: baz quuz</CODE></PRE>
<P>To see the result:</P>
<PRE><CODE>  sql $DBURL 'SELECT * FROM mytable ORDER BY Seq;'</CODE></PRE>
<P>Output will be similar to:</P>
<PRE><CODE>  Seq|Host|Starttime|JobRuntime|Send|Receive|Exitval|_Signal|Command|V1|V2|Stdout|Stderr
  1|:|1451619638.903|0.806||8|0|0|echo foo baz|foo|baz|foo baz
  |
  2|:|1451619639.265|1.54||9|0|0|echo foo quuz|foo|quuz|foo quuz
  |
  3|:|1451619640.378|1.43||8|0|0|echo bar baz|bar|baz|bar baz
  |
  4|:|1451619641.473|0.958||9|0|0|echo bar quuz|bar|quuz|bar quuz
  |</CODE></PRE>
<P>The first columns are well known from <B>--joblog</B>. <B>V1</B> and 
<B>V2</B> are data from the input sources. <B>Stdout</B> and <B>Stderr</B> are 
standard output and standard error, respectively.</P>
<H2 id="Using-multiple-workers">Using multiple workers</H2>
<P>Using an SQL base as storage costs overhead in the order of 1 second per 
job.</P>
<P>One of the situations where it makes sense is if you have multiple 
workers.</P>
<P>You can then have a single master machine that submits jobs to the SQL base 
(but does not do any of the work):</P>
<PRE><CODE>  parallel --sqlmaster $DBURLTABLE echo ::: foo bar ::: baz quuz</CODE></PRE>
<P>On the worker machines you run exactly the same command except you replace 
<B>--sqlmaster</B> with <B>--sqlworker</B>.</P>
<PRE><CODE>  parallel --sqlworker $DBURLTABLE echo ::: foo bar ::: baz quuz</CODE></PRE>
<P>To run a master and a worker on the same machine use <B>--sqlandworker</B> as 
shown earlier.</P>
<H1 id="pipe">--pipe</H1>
<P>The <B>--pipe</B> functionality puts GNU <B>parallel</B> in a different mode: 
Instead of treating the data on stdin (standard input) as arguments for a 
command to run, the data will be sent to stdin (standard input) of the 
command.</P>
<P>The typical situation is:</P>
<PRE><CODE>  command_A | command_B | command_C</CODE></PRE>
<P>where command_B is slow, and you want to speed up command_B.</P>
<H2 id="Chunk-size">Chunk size</H2>
<P>By default GNU <B>parallel</B> will start an instance of command_B, read a 
chunk of 1 MB, and pass that to the instance. Then start another instance, read 
another chunk, and pass that to the second instance.</P>
<PRE><CODE>  cat num1000000 | parallel --pipe wc</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  165668  165668 1048571
  149797  149797 1048579
  149796  149796 1048572
  149797  149797 1048579
  149797  149797 1048579
  149796  149796 1048572
   85349   85349  597444</CODE></PRE>
<P>The size of the chunk is not exactly 1 MB because GNU <B>parallel</B> only 
passes full lines - never half a line, thus the blocksize is only 1 MB on 
average. You can change the block size to 2 MB with <B>--block</B>:</P>
<PRE><CODE>  cat num1000000 | parallel --pipe --block 2M wc</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  315465  315465 2097150
  299593  299593 2097151
  299593  299593 2097151
   85349   85349  597444</CODE></PRE>
<P>GNU <B>parallel</B> treats each line as a record. If the order of records is 
unimportant (e.g. you need all lines processed, but you do not care which is 
processed first), then you can use <B>--round-robin</B>. Without 
<B>--round-robin</B> GNU <B>parallel</B> will start a command per block; with 
<B>--round-robin</B> only the requested number of jobs will be started 
(<B>--jobs</B>). The records will then be distributed between the running 
jobs:</P>
<PRE><CODE>  cat num1000000 | parallel --pipe -j4 --round-robin wc</CODE></PRE>
<P>Output will be similar to:</P>
<PRE><CODE>  149797  149797 1048579
  299593  299593 2097151
  315465  315465 2097150
  235145  235145 1646016</CODE></PRE>
<P>One of the 4 instances got a single record, 2 instances got 2 full records 
each, and one instance got 1 full and 1 partial record.</P>
<H2 id="Records">Records</H2>
<P>GNU <B>parallel</B> sees the input as records. The default record is a single 
line.</P>
<P>Using <B>-N140000</B> GNU <B>parallel</B> will read 140000 records at a 
time:</P>
<PRE><CODE>  cat num1000000 | parallel --pipe -N140000 wc</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  140000  140000  868895
  140000  140000  980000
  140000  140000  980000
  140000  140000  980000
  140000  140000  980000
  140000  140000  980000
  140000  140000  980000
   20000   20000  140001</CODE></PRE>
<P>Note how that the last job could not get the full 140000 lines, but only 
20000 lines.</P>
<P>If a record is 75 lines <B>-L</B> can be used:</P>
<PRE><CODE>  cat num1000000 | parallel --pipe -L75 wc</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  165600  165600 1048095
  149850  149850 1048950
  149775  149775 1048425
  149775  149775 1048425
  149850  149850 1048950
  149775  149775 1048425
   85350   85350  597450
      25      25     176</CODE></PRE>
<P>Note how GNU <B>parallel</B> still reads a block of around 1 MB; but instead 
of passing full lines to <B>wc</B> it passes full 75 lines at a time. This of 
course does not hold for the last job (which in this case got 25 lines).</P>
<H2 id="Record-separators">Record separators</H2>
<P>GNU <B>parallel</B> uses separators to determine where two records split.</P>
<P><B>--recstart</B> gives the string that starts a record; <B>--recend</B> 
gives the string that ends a record. The default is <B>--recend '\n'</B> 
(newline).</P>
<P>If both <B>--recend</B> and <B>--recstart</B> are given, then the record will 
only split if the recend string is immediately followed by the recstart 
string.</P>
<P>Here the <B>--recend</B> is set to <B>', '</B>:</P>
<PRE><CODE>  echo /foo, bar/, /baz, qux/, | parallel -kN1 --recend ', ' --pipe echo JOB{#}\;cat\;echo END</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  JOB1
  /foo, END
  JOB2
  bar/, END
  JOB3
  /baz, END
  JOB4
  qux/,
  END</CODE></PRE>
<P>Here the <B>--recstart</B> is set to <B>/</B>:</P>
<PRE><CODE>  echo /foo, bar/, /baz, qux/, | parallel -kN1 --recstart / --pipe echo JOB{#}\;cat\;echo END</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  JOB1
  /foo, barEND
  JOB2
  /, END
  JOB3
  /baz, quxEND
  JOB4
  /,
  END</CODE></PRE>
<P>Here both <B>--recend</B> and <B>--recstart</B> are set:</P>
<PRE><CODE>  echo /foo, bar/, /baz, qux/, | parallel -kN1 --recend ', ' --recstart / --pipe echo JOB{#}\;cat\;echo END</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  JOB1
  /foo, bar/, END
  JOB2
  /baz, qux/,
  END</CODE></PRE>
<P>Note the difference between setting one string and setting both strings.</P>
<P>With <B>--regexp</B> the <B>--recend</B> and <B>--recstart</B> will be 
treated as a regular expression:</P>
<PRE><CODE>  echo foo,bar,_baz,__qux, | parallel -kN1 --regexp --recend ,_+ --pipe echo JOB{#}\;cat\;echo END</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  JOB1
  foo,bar,_END
  JOB2
  baz,__END
  JOB3
  qux,
  END</CODE></PRE>
<P>GNU <B>parallel</B> can remove the record separators with 
<B>--remove-rec-sep</B>/<B>--rrs</B>:</P>
<PRE><CODE>  echo foo,bar,_baz,__qux, | parallel -kN1 --rrs --regexp --recend ,_+ --pipe echo JOB{#}\;cat\;echo END</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  JOB1
  foo,barEND
  JOB2
  bazEND
  JOB3
  qux,
  END</CODE></PRE>
<H2 id="Header">Header</H2>
<P>If the input data has a header, the header can be repeated for each job by 
matching the header with <B>--header</B>. If headers start with <B>%</B> you can 
do this:</P>
<PRE><CODE>  cat num_%header | parallel --header '(%.*\n)*' --pipe -N3 echo JOB{#}\;cat</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  JOB1
  %head1
  %head2
  1
  2
  3
  JOB2
  %head1
  %head2
  4
  5
  6
  JOB3
  %head1
  %head2
  7
  8
  9
  JOB4
  %head1
  %head2
  10</CODE></PRE>
<P>If the header is 2 lines, <B>--header</B> 2 will work:</P>
<PRE><CODE>  cat num_%header | parallel --header 2 --pipe -N3 echo JOB{#}\;cat</CODE></PRE>
<P>Output: Same as above.</P>
<H2 id="pipepart">--pipepart</H2>
<P><B>--pipe</B> is not very efficient. It maxes out at around 500 MB/s. 
<B>--pipepart</B> can easily deliver 5 GB/s. But there are a few limitations. 
The input has to be a normal file (not a pipe) given by <B>-a</B> or <B>::::</B> 
and <B>-L</B>/<B>-l</B>/<B>-N</B> do not work. <B>--recend</B> and 
<B>--recstart</B>, however, <I>do</I> work, and records can often be split on 
that alone.</P>
<PRE><CODE>  parallel --pipepart -a num1000000 --block 3m wc</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE> 444443  444444 3000002
 428572  428572 3000004
 126985  126984  888890</CODE></PRE>
<H1 id="Shebang">Shebang</H1>
<H2 id="Input-data-and-parallel-command-in-the-same-file">Input data and 
parallel command in the same file</H2>
<P>GNU <B>parallel</B> is often called as this:</P>
<PRE><CODE>  cat input_file | parallel command</CODE></PRE>
<P>With <B>--shebang</B> the <I>input_file</I> and <B>parallel</B> can be 
combined into the same script.</P>
<P>UNIX shell scripts start with a shebang line like this:</P>
<PRE><CODE>  #!/bin/bash</CODE></PRE>
<P>GNU <B>parallel</B> can do that, too. With <B>--shebang</B> the arguments can 
be listed in the file. The <B>parallel</B> command is the first line of the 
script:</P>
<PRE><CODE>  #!/usr/bin/parallel --shebang -r echo

  foo
  bar
  baz</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  foo
  bar
  baz</CODE></PRE>
<H2 id="Parallelizing-existing-scripts">Parallelizing existing scripts</H2>
<P>GNU <B>parallel</B> is often called as this:</P>
<PRE><CODE>  cat input_file | parallel command
  parallel command ::: foo bar</CODE></PRE>
<P>If <B>command</B> is a script, <B>parallel</B> can be combined into a single 
file so this will run the script in parallel:</P>
<PRE><CODE>  cat input_file | command
  command foo bar</CODE></PRE>
<P>This <B>perl</B> script <B>perl_echo</B> works like <B>echo</B>:</P>
<PRE><CODE>  #!/usr/bin/perl

  print "@ARGV\n"</CODE></PRE>
<P>It can be called as this:</P>
<PRE><CODE>  parallel perl_echo ::: foo bar</CODE></PRE>
<P>By changing the <B>#!</B>-line it can be run in parallel:</P>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/perl

  print "@ARGV\n"</CODE></PRE>
<P>Thus this will work:</P>
<PRE><CODE>  perl_echo foo bar</CODE></PRE>
<P>Output (the order may be different):</P>
<PRE><CODE>  foo
  bar</CODE></PRE>
<P>This technique can be used for:</P>
<DL>
  <DT id="Perl">Perl:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/perl
  
  print "Arguments @ARGV\n";</CODE></PRE></DD>
  <DT id="Python">Python:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/python
  
  import sys
  print 'Arguments', str(sys.argv)</CODE></PRE></DD>
  <DT id="Bash-sh-zsh-Korn-shell">Bash/sh/zsh/Korn shell:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /bin/bash
  
  echo Arguments "$@"</CODE></PRE></DD>
  <DT id="csh">csh:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /bin/csh
  
  echo Arguments "$argv"</CODE></PRE></DD>
  <DT id="Tcl">Tcl:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/tclsh
  
  puts "Arguments $argv"</CODE></PRE></DD>
  <DT id="R">R:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/Rscript --vanilla --slave
  
  args &lt;- commandArgs(trailingOnly = TRUE)
  print(paste("Arguments ",args))</CODE></PRE></DD>
  <DT id="GNUplot">GNUplot:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap ARG={} /usr/bin/gnuplot
  
  print "Arguments ", system('echo $ARG')</CODE></PRE></DD>
  <DT id="Ruby">Ruby:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/ruby
  
  print "Arguments "
  puts ARGV</CODE></PRE></DD>
  <DT id="Octave">Octave:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/octave
  
  printf ("Arguments");
  arg_list = argv ();
  for i = 1:nargin
    printf (" %s", arg_list{i});
  endfor
  printf ("\n");</CODE></PRE></DD>
  <DT id="Common-LISP">Common LISP:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/clisp
  
  (format t "~&amp;~S~&amp;" 'Arguments)
  (format t "~&amp;~S~&amp;" *args*)</CODE></PRE></DD>
  <DT id="PHP">PHP:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/php
  &lt;?php
  echo "Arguments";
  foreach(array_slice($argv,1) as $v)
  {
    echo " $v";
  }
  echo "\n";
  ?&gt;</CODE></PRE></DD>
  <DT id="Node.js">Node.js:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/node

  var myArgs = process.argv.slice(2);
  console.log('Arguments ', myArgs);</CODE></PRE></DD>
  <DT id="LUA">LUA:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap /usr/bin/lua
  
  io.write "Arguments"
  for a = 1, #arg do
    io.write(" ")
    io.write(arg[a])
  end
  print("")</CODE></PRE></DD>
  <DT id="C">C#:</DT>
  <DD>
<PRE><CODE>  #!/usr/bin/parallel --shebang-wrap ARGV={} /usr/bin/csharp
  
  var argv = Environment.GetEnvironmentVariable("ARGV");
  print("Arguments "+argv);</CODE></PRE></DD></DL>
<H1 id="Semaphore">Semaphore</H1>
<P>GNU <B>parallel</B> can work as a counting semaphore. This is slower and less 
efficient than its normal mode.</P>
<P>A counting semaphore is like a row of toilets. People needing a toilet can 
use any toilet, but if there are more people than toilets, they will have to 
wait for one of the toilets to become available.</P>
<P>An alias for <B>parallel --semaphore</B> is <B>sem</B>.</P>
<P><B>sem</B> will follow a person to the toilets, wait until a toilet is 
available, leave the person in the toilet and exit.</P>
<P><B>sem --fg</B> will follow a person to the toilets, wait until a toilet is 
available, stay with the person in the toilet and exit when the person 
exits.</P>
<P><B>sem --wait</B> will wait for all persons to leave the toilets.</P>
<P><B>sem</B> does not have a queue discipline, so the next person is chosen 
randomly.</P>
<P><B>-j</B> sets the number of toilets.</P>
<H2 id="Mutex">Mutex</H2>
<P>The default is to have only one toilet (this is called a mutex). The program 
is started in the background and <B>sem</B> exits immediately. Use <B>--wait</B> 
to wait for all <B>sem</B>s to finish:</P>
<PRE><CODE>  sem 'sleep 1; echo The first finished' &amp;&amp;
    echo The first is now running in the background &amp;&amp;
    sem 'sleep 1; echo The second finished' &amp;&amp;
    echo The second is now running in the background
  sem --wait</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  The first is now running in the background
  The first finished
  The second is now running in the background
  The second finished</CODE></PRE>
<P>The command can be run in the foreground with <B>--fg</B>, which will only 
exit when the command completes:</P>
<PRE><CODE>  sem --fg 'sleep 1; echo The first finished' &amp;&amp;
    echo The first finished running in the foreground &amp;&amp;
    sem --fg 'sleep 1; echo The second finished' &amp;&amp;
    echo The second finished running in the foreground
  sem --wait</CODE></PRE>
<P>The difference between this and just running the command, is that a mutex is 
set, so if other <B>sem</B>s were running in the background only one would run 
at a time.</P>
<P>To control which semaphore is used, use <B>--semaphorename</B>/<B>--id</B>. 
Run this in one terminal:</P>
<PRE><CODE>  sem --id my_id -u 'echo First started; sleep 10; echo The first finished'</CODE></PRE>
<P>and simultaneously this in another terminal:</P>
<PRE><CODE>  sem --id my_id -u 'echo Second started; sleep 10; echo The second finished'</CODE></PRE>
<P>Note how the second will only be started when the first has finished.</P>
<H2 id="Counting-semaphore">Counting semaphore</H2>
<P>A mutex is like having a single toilet: When it is in use everyone else will 
have to wait. A counting semaphore is like having multiple toilets: Several 
people can use the toilets, but when they all are in use, everyone else will 
have to wait.</P>
<P><B>sem</B> can emulate a counting semaphore. Use <B>--jobs</B> to set the 
number of toilets like this:</P>
<PRE><CODE>  sem --jobs 3 --id my_id -u 'echo First started; sleep 5; echo The first finished' &amp;&amp;
  sem --jobs 3 --id my_id -u 'echo Second started; sleep 6; echo The second finished' &amp;&amp;
  sem --jobs 3 --id my_id -u 'echo Third started; sleep 7; echo The third finished' &amp;&amp;
  sem --jobs 3 --id my_id -u 'echo Fourth started; sleep 8; echo The fourth finished' &amp;&amp;
  sem --wait --id my_id</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  First started
  Second started
  Third started
  The first finished
  Fourth started
  The second finished
  The third finished
  The fourth finished</CODE></PRE>
<H2 id="Timeout">Timeout</H2>
<P>With <B>--semaphoretimeout</B> you can force running the command anyway after 
a period (postive number) or give up (negative number):</P>
<PRE><CODE>  sem --id foo -u 'echo Slow started; sleep 5; echo Slow ended' &amp;&amp;
  sem --id foo --semaphoretimeout 1 'echo Force this running after 1 sec' &amp;&amp;
  sem --id foo --semaphoretimeout -2 'echo Give up after 1 sec'
  sem --id foo --wait</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Slow started
  parallel: Warning: Semaphore timed out. Stealing the semaphore.
  Force this running after 1 sec
  Slow ended
  parallel: Warning: Semaphore timed out. Exiting.</CODE></PRE>
<P>Note how the 'Give up' was not run.</P>
<H1 id="Informational">Informational</H1>
<P>GNU <B>parallel</B> has some options to give short information about the 
configuration.</P>
<P><B>--help</B> will print a summary of the most important options:</P>
<PRE><CODE>  parallel --help</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Usage:
  
  parallel [options] [command [arguments]] &lt; list_of_arguments
  parallel [options] [command [arguments]] (::: arguments|:::: argfile(s))...
  cat ... | parallel --pipe [options] [command [arguments]]
  
  -j n            Run n jobs in parallel
  -k              Keep same order
  -X              Multiple arguments with context replace
  --colsep regexp Split input on regexp for positional replacements
  {} {.} {/} {/.} {#} {%} {= perl code =} Replacement strings
  {3} {3.} {3/} {3/.} {=3 perl code =}    Positional replacement strings
  With --plus:    {} = {+/}/{/} = {.}.{+.} = {+/}/{/.}.{+.} = {..}.{+..} =
                  {+/}/{/..}.{+..} = {...}.{+...} = {+/}/{/...}.{+...}
  
  -S sshlogin     Example: foo@server.example.com
  --slf ..        Use ~/.parallel/sshloginfile as the list of sshlogins
  --trc {}.bar    Shorthand for --transfer --return {}.bar --cleanup
  --onall         Run the given command with argument on all sshlogins
  --nonall        Run the given command with no arguments on all sshlogins
  
  --pipe          Split stdin (standard input) to multiple jobs.
  --recend str    Record end separator for --pipe.
  --recstart str  Record start separator for --pipe.
  
  See 'man parallel' for details
  
  Academic tradition requires you to cite works you base your article on.
  When using programs that use GNU Parallel to process data for publication
  please cite:
  
    O. Tange (2011): GNU Parallel - The Command-Line Power Tool,
    ;login: The USENIX Magazine, February 2011:42-47.
  
  This helps funding further development; AND IT WON'T COST YOU A CENT.
  If you pay 10000 EUR you should feel free to use GNU Parallel without citing.</CODE></PRE>
<P>When asking for help, always report the full output of this:</P>
<PRE><CODE>  parallel --version</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  GNU parallel 20160323
  Copyright (C) 2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017
  Ole Tange and Free Software Foundation, Inc.
  License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
  This is free software: you are free to change and redistribute it.
  GNU parallel comes with no warranty.
  
  Web site: http://www.gnu.org/software/parallel
  
  When using programs that use GNU Parallel to process data for publication
  please cite as described in 'parallel --citation'.</CODE></PRE>
<P>In scripts <B>--minversion</B> can be used to ensure the user has at least 
this version:</P>
<PRE><CODE>  parallel --minversion 20130722 &amp;&amp; echo Your version is at least 20130722.</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  20160322
  Your version is at least 20130722.</CODE></PRE>
<P>If you are using GNU <B>parallel</B> for research the BibTeX citation can be 
generated using <B>--citation</B>:</P>
<PRE><CODE>  parallel --citation</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  Academic tradition requires you to cite works you base your article on.
  When using programs that use GNU Parallel to process data for publication
  please cite:
  
  @article{Tange2011a,
    title = {GNU Parallel - The Command-Line Power Tool},
    author = {O. Tange},
    address = {Frederiksberg, Denmark},
    journal = {;login: The USENIX Magazine},
    month = {Feb},
    number = {1},
    volume = {36},
    url = {http://www.gnu.org/s/parallel},
    year = {2011},
    pages = {42-47},
    doi = {10.5281/zenodo.16303}
  }
  
  (Feel free to use \nocite{Tange2011a})
  
  This helps funding further development; AND IT WON'T COST YOU A CENT.
  If you pay 10000 EUR you should feel free to use GNU Parallel without citing.
  
  If you send a copy of your published article to tange@gnu.org, it will be
  mentioned in the release notes of next version of GNU Parallel.
  </CODE></PRE>
<P>With <B>--max-line-length-allowed</B> GNU <B>parallel</B> will report the 
maximal size of the command line:</P>
<PRE><CODE>  parallel --max-line-length-allowed</CODE></PRE>
<P>Output (may vary on different systems):</P>
<PRE><CODE>  131071</CODE></PRE>
<P><B>--number-of-cpus</B> and <B>--number-of-cores</B> run system specific code 
to determine the number of CPUs and CPU cores on the system. On unsupported 
platforms they will return 1:</P>
<PRE><CODE>  parallel --number-of-cpus
  parallel --number-of-cores</CODE></PRE>
<P>Output (may vary on different systems):</P>
<PRE><CODE>  4
  64</CODE></PRE>
<H1 id="Profiles">Profiles</H1>
<P>The defaults for GNU <B>parallel</B> can be changed systemwide by putting the 
command line options in <B>/etc/parallel/config</B>. They can be changed for a 
user by putting them in <B>~/.parallel/config</B>.</P>
<P>Profiles work the same way, but have to be referred to with 
<B>--profile</B>:</P>
<PRE><CODE>  echo '--nice 17' &gt; ~/.parallel/nicetimeout
  echo '--timeout 300%' &gt;&gt; ~/.parallel/nicetimeout
  parallel --profile nicetimeout echo ::: A B C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  A
  B
  C</CODE></PRE>
<P>Profiles can be combined:</P>
<PRE><CODE>  echo '-vv --dry-run' &gt; ~/.parallel/dryverbose
  parallel --profile dryverbose --profile nicetimeout echo ::: A B C</CODE></PRE>
<P>Output:</P>
<PRE><CODE>  echo A
  echo B
  echo C</CODE></PRE>
<H1 id="Spread-the-word">Spread the word</H1>
<P>I hope you have learned something from this tutorial.</P>
<P>If you like GNU <B>parallel</B>:</P>
<UL>
  <LI>
  <P>(Re-)walk through the tutorial if you have not done so in the past year 
  (http://www.gnu.org/software/parallel/parallel_tutorial.html)</P></LI>
  <LI>
  <P>Give a demo at your local user group/your team/your colleagues</P></LI>
  <LI>
  <P>Post the intro videos and the tutorial on Reddit, Diaspora*, forums, blogs, 
  Identi.ca, Google+, Twitter, Facebook, Linkedin, and mailing lists</P></LI>
  <LI>
  <P>Request or write a review for your favourite blog or magazine (especially 
  if you do something cool with GNU <B>parallel</B>)</P></LI>
  <LI>
  <P>Invite me for your next conference</P></LI></UL>
<P>If you use GNU <B>parallel</B> for research:</P>
<UL>
  <LI>
  <P>Please cite GNU <B>parallel</B> in you publications (use 
  <B>--citation</B>)</P></LI></UL>
<P>If GNU <B>parallel</B> saves you money:</P>
<UL>
  <LI>
  <P>(Have your company) donate to FSF or become a member 
  https://my.fsf.org/donate/</P></LI></UL>
<P>(C) 2013,2014,2015,2016,2017 Ole Tange, GPLv3</P></BODY></HTML>
